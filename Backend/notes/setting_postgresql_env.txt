Why We Changed settings.py to Modular Settings
ğŸ”¹ Before (Default Django)

Django gives:

config/settings.py

Everything inside one file:

Database

Debug

Installed apps

Middleware

Secrets

Production config

That works for small projectsâ€¦
But becomes messy in real-world applications.

ğŸ”¹ Problem With Single settings.py

âŒ Hard to manage large configs

âŒ Risky for production

âŒ Secrets get hardcoded

âŒ Cannot separate dev vs prod properly

âŒ Not scalable

In companies, environments are different:

Development (local machine)

Staging (testing server)

Production (live server)

Each environment needs different configs.

ğŸ—ï¸ Why We Split Settings (base / development / production)

We created:

config/settings/
    base.py
    development.py
    production.py
ğŸ”¹ base.py

Purpose:
ğŸ‘‰ Contains common settings shared by all environments.

Examples:

INSTALLED_APPS

Middleware

Templates

Database config (dynamic)

REST framework config

Think of base.py as:

The foundation of the building.

ğŸ”¹ development.py

Purpose:
ğŸ‘‰ Used only for local development.

Contains:

DEBUG = True

ALLOWED_HOSTS = []

Why?

Because:

We want error stack traces locally

We want relaxed security

We want easy debugging

ğŸ”¹ production.py

Purpose:
ğŸ‘‰ Used when deploying to live server.

Contains:

DEBUG = False

Secure host settings

Security middleware

Strict allowed hosts

Why?

Because:

You must not expose debug info in production

You must enable security headers

You must protect from attacks

ğŸ” Why We Introduced .env File

Now the important part.

Originally, many beginners write:

DATABASES = {
    'default': {
        'PASSWORD': '123456'
    }
}

ğŸš¨ This is dangerous.

ğŸ”´ Problems with Hardcoding Secrets

Password visible in code

If pushed to GitHub â†’ exposed

Cannot change per environment

Not secure in production

ğŸŒ± What is .env File?

.env stores:

Database credentials

Secret keys

API keys

Tokens

Example:

DB_NAME=todo_db
DB_USER=postgres
DB_PASSWORD=yourpassword

This file:

Is NOT committed to Git

Is environment-specific

Keeps secrets safe

ğŸ§° Why We Used python-decouple

We installed:

pip install python-decouple

Purpose:
ğŸ‘‰ Read environment variables cleanly.

Instead of:

import os
os.environ['DB_NAME']

We use:

from decouple import config
config('DB_NAME')

Cleaner, safer, production-friendly.

ğŸ˜ Why We Switched to PostgreSQL

By default Django uses SQLite.

But:

ğŸ”¹ SQLite

File-based

Good for learning

Not scalable

Limited concurrency

ğŸ”¹ PostgreSQL

Production-grade

Handles concurrent users

Advanced indexing

Better performance

Used in real companies

Since you're building:

A full-stack production-level project

PostgreSQL is the correct choice.

ğŸ§± Why Database Config Goes in base.py

Because:

Both development and production use database

Only credentials change

Structure stays same

So we centralize config in base.py.

ğŸ”„ Why This Architecture is Powerful

Now imagine:

Development

You use:

.env (local database)
DEBUG=True
Production

Server has:

.env (production database)
DEBUG=False

Code remains same.

Only environment changes.

This is professional design.

ğŸ§  Big Picture Understanding

We did 3 major engineering-level upgrades:

1ï¸âƒ£ Split settings â†’ scalability
2ï¸âƒ£ Used environment variables â†’ security
3ï¸âƒ£ Switched to PostgreSQL â†’ production readiness

This is not tutorial code anymore.
This is how backend systems are structured in real companies.